#!/usr/bin/env bash

set -euo pipefail

################################################################################
# Changelog Generator
################################################################################
#
# This script helps you create a new CHANGELOG.md entry for an upcoming release.
#
# WHAT IT DOES:
# - Finds all commits since the last release tag (e.g., v0.42.0)
# - Automatically categorizes them into ENHANCEMENTS, BUGFIXES, and HOUSEKEEPING
#   based on commit message prefixes (feat, fix, maint/chore)
# - Prompts you for the new version number and release date
# - Generates a formatted changelog entry and prepends it to CHANGELOG.md
#
# WHEN TO USE:
# - Run this before creating a new release to automatically generate the
#   changelog entry from your git history
#
# BASIC USAGE:
#   ./scripts/generate-changelog
#
# The script will:
# 1. Show you all commits since the last release
# 2. Ask for the new version number (e.g., 0.43.0)
# 3. Ask for the release date (or use today's date)
# 4. Show you a preview of the changelog entry
# 5. Ask for confirmation before updating CHANGELOG.md
#
# OPTIONS:
#   --check-labels    Use GitHub CLI (gh) to check for 'no-changelog' label
#                     on PRs and skip those commits
#   --help, -h        Show help message
#
# EXAMPLES:
#   # Basic usage - generate changelog from git history
#   ./scripts/generate-changelog
#
#   # Check GitHub PR labels to skip commits with 'no-changelog' label
#   ./scripts/generate-changelog --check-labels
#
# COMMIT FORMAT:
# For best results, use conventional commit prefixes:
# - feat: or feat(...):  -> Goes in ENHANCEMENTS
# - fix: or fix(...):    -> Goes in BUGFIXES
# - maint: or chore:     -> Goes in HOUSEKEEPING
# - rel:                 -> Skipped (release commits)
#
# Commits without standard prefixes will be added to HOUSEKEEPING with a warning.
#
################################################################################

# Script to generate CHANGELOG entries from git commits since the last release

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
CHANGELOG_FILE="CHANGELOG.md"
CHECK_LABELS=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --check-labels)
      CHECK_LABELS=true
      shift
      ;;
    --help|-h)
      echo "Usage: $0 [OPTIONS]"
      echo ""
      echo "Generate CHANGELOG entries from git commits since the last release"
      echo ""
      echo "OPTIONS:"
      echo "  --check-labels    Use GitHub CLI to check for 'no-changelog' label on PRs"
      echo "  --help, -h        Show this help message"
      echo ""
      exit 0
      ;;
    *)
      echo -e "${RED}Error: Unknown option $1${NC}"
      echo "Use --help for usage information"
      exit 1
      ;;
  esac
done

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo -e "${RED}Error: Not in a git repository${NC}"
  exit 1
fi

# Check if CHANGELOG.md exists
if [[ ! -f "$CHANGELOG_FILE" ]]; then
  echo -e "${RED}Error: $CHANGELOG_FILE not found${NC}"
  exit 1
fi

# Check if gh CLI is available when --check-labels is used
if [[ "$CHECK_LABELS" == true ]]; then
  if ! command -v gh &> /dev/null; then
    echo -e "${RED}Error: GitHub CLI (gh) is not installed or not in PATH${NC}"
    echo "Install it from https://cli.github.com/ or run without --check-labels"
    exit 1
  fi
fi

# Find the most recent release tag
echo -e "${BLUE}Finding the most recent release tag...${NC}"
LATEST_TAG=$(git tag -l 'v*.*.*' | sort -V | tail -n 1)

if [[ -z "$LATEST_TAG" ]]; then
  echo -e "${RED}Error: No release tags found (expected format: v*.*.*)${NC}"
  exit 1
fi

echo -e "${GREEN}Latest release: $LATEST_TAG${NC}"

# Get commits since the last release
COMMIT_RANGE="${LATEST_TAG}..HEAD"
COMMITS=$(git log "$COMMIT_RANGE" --oneline --no-merges)

if [[ -z "$COMMITS" ]]; then
  echo -e "${YELLOW}No commits found since $LATEST_TAG${NC}"
  exit 0
fi

echo -e "${BLUE}Found $(echo "$COMMITS" | wc -l | tr -d ' ') commits since $LATEST_TAG${NC}"
echo ""

# Arrays to hold categorized commits
declare -a ENHANCEMENTS=()
declare -a BUGFIXES=()
declare -a HOUSEKEEPING=()
declare -a WARNINGS=()

# Function to check if a PR has the no-changelog label
has_no_changelog_label() {
  local pr_number="$1"
  if [[ "$CHECK_LABELS" == true ]]; then
    local labels
    labels=$(gh pr view "$pr_number" --json labels --jq '.labels[].name' 2>/dev/null || echo "")
    if echo "$labels" | grep -q "no-changelog"; then
      return 0
    fi
  fi
  return 1
}

# Process each commit
while IFS= read -r commit; do
  # Extract commit hash and message
  hash=$(echo "$commit" | awk '{print $1}')
  message=$(echo "$commit" | cut -d' ' -f2-)

  # Extract PR number if present
  pr_number=""
  if [[ "$message" =~ \(#([0-9]+)\) ]]; then
    pr_number="${BASH_REMATCH[1]}"
  fi

  # Check if PR has no-changelog label
  if [[ -n "$pr_number" ]] && has_no_changelog_label "$pr_number"; then
    echo -e "${YELLOW}Skipping #$pr_number (has no-changelog label)${NC}"
    continue
  fi

  # Skip release commits
  if [[ "$message" =~ ^rel: ]]; then
    echo -e "${YELLOW}Skipping release commit: $message${NC}"
    continue
  fi

  # Categorize based on prefix
  if [[ "$message" =~ ^feat ]]; then
    ENHANCEMENTS+=("* $message")
    echo -e "${GREEN}[ENHANCEMENT]${NC} $message"
  elif [[ "$message" =~ ^fix ]]; then
    BUGFIXES+=("* $message")
    echo -e "${GREEN}[BUGFIX]${NC} $message"
  elif [[ "$message" =~ ^maint ]] || [[ "$message" =~ ^chore ]]; then
    HOUSEKEEPING+=("* $message")
    echo -e "${GREEN}[HOUSEKEEPING]${NC} $message"
  else
    # Non-standard format - warn but include in HOUSEKEEPING
    HOUSEKEEPING+=("* $message")
    WARNINGS+=("$message")
    echo -e "${YELLOW}[HOUSEKEEPING - WARNING: non-standard format]${NC} $message"
  fi
done <<< "$COMMITS"

echo ""

# Show warnings if any
if [[ ${#WARNINGS[@]} -gt 0 ]]; then
  echo -e "${YELLOW}⚠ Warning: Found ${#WARNINGS[@]} commit(s) with non-standard format:${NC}"
  for warning in "${WARNINGS[@]}"; do
    echo -e "  - $warning"
  done
  echo -e "${YELLOW}These have been added to HOUSEKEEPING but may need manual review.${NC}"
  echo ""
fi

# Prompt for version number
echo -e "${BLUE}Enter the new version number (e.g., 0.43.0):${NC}"
read -r VERSION

if [[ -z "$VERSION" ]]; then
  echo -e "${RED}Error: Version number is required${NC}"
  exit 1
fi

# Validate version format
if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
  echo -e "${RED}Error: Invalid version format. Expected format: X.Y.Z${NC}"
  exit 1
fi

# Prompt for release date
echo -e "${BLUE}Enter the release date (e.g., Nov 25, 2025) [default: today]:${NC}"
read -r RELEASE_DATE

if [[ -z "$RELEASE_DATE" ]]; then
  RELEASE_DATE=$(date "+%b %d, %Y")
fi

# Build the changelog entry
CHANGELOG_ENTRY="# $VERSION ($RELEASE_DATE)"

# Add ENHANCEMENTS section if there are any
if [[ ${#ENHANCEMENTS[@]} -gt 0 ]]; then
  CHANGELOG_ENTRY+="\n\nENHANCEMENTS:\n"
  for item in "${ENHANCEMENTS[@]}"; do
    CHANGELOG_ENTRY+="\n$item"
  done
fi

# Add BUGFIXES section if there are any
if [[ ${#BUGFIXES[@]} -gt 0 ]]; then
  CHANGELOG_ENTRY+="\n\nBUGFIXES:\n"
  for item in "${BUGFIXES[@]}"; do
    CHANGELOG_ENTRY+="\n$item"
  done
fi

# Add HOUSEKEEPING section if there are any
if [[ ${#HOUSEKEEPING[@]} -gt 0 ]]; then
  CHANGELOG_ENTRY+="\n\nHOUSEKEEPING:\n"
  for item in "${HOUSEKEEPING[@]}"; do
    CHANGELOG_ENTRY+="\n$item"
  done
fi

# Add spacing before next entry
CHANGELOG_ENTRY+="\n"

# Show preview
echo ""
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Preview of changelog entry:${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "$CHANGELOG_ENTRY"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""

# Confirm before updating
echo -e "${YELLOW}Update $CHANGELOG_FILE with this entry? (y/n)${NC}"
read -r CONFIRM

if [[ "$CONFIRM" != "y" && "$CONFIRM" != "Y" ]]; then
  echo -e "${YELLOW}Aborted. No changes made.${NC}"
  exit 0
fi

# Create a temporary file with the new changelog
TEMP_FILE=$(mktemp)
echo -e "$CHANGELOG_ENTRY" > "$TEMP_FILE"
cat "$CHANGELOG_FILE" >> "$TEMP_FILE"

# Replace the original file
mv "$TEMP_FILE" "$CHANGELOG_FILE"

echo -e "${GREEN}✓ Successfully updated $CHANGELOG_FILE${NC}"
echo ""
echo -e "${BLUE}Summary:${NC}"
echo -e "  Version: ${GREEN}$VERSION${NC}"
echo -e "  Release Date: ${GREEN}$RELEASE_DATE${NC}"
echo -e "  Enhancements: ${GREEN}${#ENHANCEMENTS[@]}${NC}"
echo -e "  Bugfixes: ${GREEN}${#BUGFIXES[@]}${NC}"
echo -e "  Housekeeping: ${GREEN}${#HOUSEKEEPING[@]}${NC}"
if [[ ${#WARNINGS[@]} -gt 0 ]]; then
  echo -e "  ${YELLOW}⚠ Non-standard commits: ${#WARNINGS[@]}${NC}"
fi
echo ""
echo -e "${BLUE}Next steps:${NC}"
echo "1. Review the updated $CHANGELOG_FILE"
echo "2. If this is a non-patch release, update version references in README.md and docs/index.md"
echo "3. Create a release commit and tag"
